// Code generated by genparse grammar.go; DO NOT EDIT
// +build !nocompiledgrammar
// Use this tag to disable the generated implementations of Parse below

package json

import "github.com/arnodel/grammar"

// Parse implements parses the given token stream into the receiver according to
// the rule defined by Array.
func (r *Array) Parse(s grammar.TokenStream, opts grammar.ParseOptions) (err *grammar.ParseError) {
	// This is a sequence rule.
	{
		opts = grammar.ParseOptions{
			TokenType:  "op",
			TokenValue: "[",
		}
		// Parse Token.
		var dest Token
		if fieldErr := grammar.ParseWithOptions(&dest, s, opts); fieldErr != nil {
			return fieldErr
		}
		r.Open = dest
	}
	{
		opts = grammar.ParseOptions{
			TokenType:  "",
			TokenValue: "",
		}
		// Parse optional ArrayBody.
		startOpt := s.Save()
		var dest ArrayBody
		if fieldErr := dest.Parse(s, opts); fieldErr != nil {
			s.Restore(startOpt)
		} else {
			r.ArrayBody = &dest
		}
	}
	{
		opts = grammar.ParseOptions{
			TokenType:  "op",
			TokenValue: "]",
		}
		// Parse Token.
		var dest Token
		if fieldErr := grammar.ParseWithOptions(&dest, s, opts); fieldErr != nil {
			return fieldErr
		}
		r.Close = dest
	}
	return nil
}

// Parse implements parses the given token stream into the receiver according to
// the rule defined by ArrayBody.
func (r *ArrayBody) Parse(s grammar.TokenStream, opts grammar.ParseOptions) (err *grammar.ParseError) {
	// This is a sequence rule.
	{
		opts = grammar.ParseOptions{
			TokenType:  "",
			TokenValue: "",
		}
		// Parse Json.
		var dest Json
		if fieldErr := dest.Parse(s, opts); fieldErr != nil {
			return fieldErr
		}
		r.First = dest
	}
	{
		opts = grammar.ParseOptions{
			TokenType:  "",
			TokenValue: "",
		}
		// Parse optional sequence of ArrayItem items.
		var dests []ArrayItem
		for {
			startOpt := s.Save()
			var dest ArrayItem
			if fieldErr := dest.Parse(s, opts); fieldErr != nil {
				s.Restore(startOpt)
				break
			}
			dests = append(dests, dest)
		}
		r.Items = dests
	}
	return nil
}

// Parse implements parses the given token stream into the receiver according to
// the rule defined by ArrayItem.
func (r *ArrayItem) Parse(s grammar.TokenStream, opts grammar.ParseOptions) (err *grammar.ParseError) {
	// This is a sequence rule.
	{
		opts = grammar.ParseOptions{
			TokenType:  "op",
			TokenValue: ",",
		}
		// Parse Token.
		var dest Token
		if fieldErr := grammar.ParseWithOptions(&dest, s, opts); fieldErr != nil {
			return fieldErr
		}
		r.Comma = dest
	}
	{
		opts = grammar.ParseOptions{
			TokenType:  "",
			TokenValue: "",
		}
		// Parse Json.
		var dest Json
		if fieldErr := dest.Parse(s, opts); fieldErr != nil {
			return fieldErr
		}
		r.Value = dest
	}
	return nil
}

// Parse implements parses the given token stream into the receiver according to
// the rule defined by Bool.
func (r *Bool) Parse(s grammar.TokenStream, opts grammar.ParseOptions) (err *grammar.ParseError) {
	// This is a sequence rule.
	{
		opts = grammar.ParseOptions{
			TokenType:  "bool",
			TokenValue: "",
		}
		// Parse Token.
		var dest Token
		if fieldErr := grammar.ParseWithOptions(&dest, s, opts); fieldErr != nil {
			return fieldErr
		}
		r.Value = dest
	}
	return nil
}

// Parse implements parses the given token stream into the receiver according to
// the rule defined by Dict.
func (r *Dict) Parse(s grammar.TokenStream, opts grammar.ParseOptions) (err *grammar.ParseError) {
	// This is a sequence rule.
	{
		opts = grammar.ParseOptions{
			TokenType:  "op",
			TokenValue: "{",
		}
		// Parse Token.
		var dest Token
		if fieldErr := grammar.ParseWithOptions(&dest, s, opts); fieldErr != nil {
			return fieldErr
		}
		r.Open = dest
	}
	{
		opts = grammar.ParseOptions{
			TokenType:  "",
			TokenValue: "",
		}
		// Parse optional DictBody.
		startOpt := s.Save()
		var dest DictBody
		if fieldErr := dest.Parse(s, opts); fieldErr != nil {
			s.Restore(startOpt)
		} else {
			r.DictBody = &dest
		}
	}
	{
		opts = grammar.ParseOptions{
			TokenType:  "op",
			TokenValue: "}",
		}
		// Parse Token.
		var dest Token
		if fieldErr := grammar.ParseWithOptions(&dest, s, opts); fieldErr != nil {
			return fieldErr
		}
		r.Close = dest
	}
	return nil
}

// Parse implements parses the given token stream into the receiver according to
// the rule defined by DictBody.
func (r *DictBody) Parse(s grammar.TokenStream, opts grammar.ParseOptions) (err *grammar.ParseError) {
	// This is a sequence rule.
	{
		opts = grammar.ParseOptions{
			TokenType:  "",
			TokenValue: "",
		}
		// Parse KeyValue.
		var dest KeyValue
		if fieldErr := dest.Parse(s, opts); fieldErr != nil {
			return fieldErr
		}
		r.First = dest
	}
	{
		opts = grammar.ParseOptions{
			TokenType:  "",
			TokenValue: "",
		}
		// Parse optional sequence of DictItem items.
		var dests []DictItem
		for {
			startOpt := s.Save()
			var dest DictItem
			if fieldErr := dest.Parse(s, opts); fieldErr != nil {
				s.Restore(startOpt)
				break
			}
			dests = append(dests, dest)
		}
		r.Items = dests
	}
	return nil
}

// Parse implements parses the given token stream into the receiver according to
// the rule defined by DictItem.
func (r *DictItem) Parse(s grammar.TokenStream, opts grammar.ParseOptions) (err *grammar.ParseError) {
	// This is a sequence rule.
	{
		opts = grammar.ParseOptions{
			TokenType:  "op",
			TokenValue: ",",
		}
		// Parse Token.
		var dest Token
		if fieldErr := grammar.ParseWithOptions(&dest, s, opts); fieldErr != nil {
			return fieldErr
		}
		r.Comma = dest
	}
	{
		opts = grammar.ParseOptions{
			TokenType:  "",
			TokenValue: "",
		}
		// Parse KeyValue.
		var dest KeyValue
		if fieldErr := dest.Parse(s, opts); fieldErr != nil {
			return fieldErr
		}
		r.KeyValue = dest
	}
	return nil
}

// Parse implements parses the given token stream into the receiver according to
// the rule defined by Json.
func (r *Json) Parse(s grammar.TokenStream, opts grammar.ParseOptions) (err *grammar.ParseError) {
	// This is a one-of rule.
	{
		opts = grammar.ParseOptions{
			TokenType:  "",
			TokenValue: "",
		}
		// Parse optional Number.
		startOpt := s.Save()
		var dest Number
		fieldErr := dest.Parse(s, opts)
		if fieldErr == nil {
			r.Number = &dest
			return nil
		}
		s.Restore(startOpt)
		err = err.Merge(fieldErr)
	}
	{
		opts = grammar.ParseOptions{
			TokenType:  "",
			TokenValue: "",
		}
		// Parse optional String.
		startOpt := s.Save()
		var dest String
		fieldErr := dest.Parse(s, opts)
		if fieldErr == nil {
			r.String = &dest
			return nil
		}
		s.Restore(startOpt)
		err = err.Merge(fieldErr)
	}
	{
		opts = grammar.ParseOptions{
			TokenType:  "",
			TokenValue: "",
		}
		// Parse optional Null.
		startOpt := s.Save()
		var dest Null
		fieldErr := dest.Parse(s, opts)
		if fieldErr == nil {
			r.Null = &dest
			return nil
		}
		s.Restore(startOpt)
		err = err.Merge(fieldErr)
	}
	{
		opts = grammar.ParseOptions{
			TokenType:  "",
			TokenValue: "",
		}
		// Parse optional Bool.
		startOpt := s.Save()
		var dest Bool
		fieldErr := dest.Parse(s, opts)
		if fieldErr == nil {
			r.Bool = &dest
			return nil
		}
		s.Restore(startOpt)
		err = err.Merge(fieldErr)
	}
	{
		opts = grammar.ParseOptions{
			TokenType:  "",
			TokenValue: "",
		}
		// Parse optional Array.
		startOpt := s.Save()
		var dest Array
		fieldErr := dest.Parse(s, opts)
		if fieldErr == nil {
			r.Array = &dest
			return nil
		}
		s.Restore(startOpt)
		err = err.Merge(fieldErr)
	}
	{
		opts = grammar.ParseOptions{
			TokenType:  "",
			TokenValue: "",
		}
		// Parse optional Dict.
		startOpt := s.Save()
		var dest Dict
		fieldErr := dest.Parse(s, opts)
		if fieldErr == nil {
			r.Dict = &dest
			return nil
		}
		s.Restore(startOpt)
		err = err.Merge(fieldErr)
	}
	return err
}

// Parse implements parses the given token stream into the receiver according to
// the rule defined by KeyValue.
func (r *KeyValue) Parse(s grammar.TokenStream, opts grammar.ParseOptions) (err *grammar.ParseError) {
	// This is a sequence rule.
	{
		opts = grammar.ParseOptions{
			TokenType:  "",
			TokenValue: "",
		}
		// Parse String.
		var dest String
		if fieldErr := dest.Parse(s, opts); fieldErr != nil {
			return fieldErr
		}
		r.Key = dest
	}
	{
		opts = grammar.ParseOptions{
			TokenType:  "op",
			TokenValue: ":",
		}
		// Parse Token.
		var dest Token
		if fieldErr := grammar.ParseWithOptions(&dest, s, opts); fieldErr != nil {
			return fieldErr
		}
		r.Colon = dest
	}
	{
		opts = grammar.ParseOptions{
			TokenType:  "",
			TokenValue: "",
		}
		// Parse Json.
		var dest Json
		if fieldErr := dest.Parse(s, opts); fieldErr != nil {
			return fieldErr
		}
		r.Value = dest
	}
	return nil
}

// Parse implements parses the given token stream into the receiver according to
// the rule defined by Null.
func (r *Null) Parse(s grammar.TokenStream, opts grammar.ParseOptions) (err *grammar.ParseError) {
	// This is a sequence rule.
	{
		opts = grammar.ParseOptions{
			TokenType:  "null",
			TokenValue: "null",
		}
		// Parse Token.
		var dest Token
		if fieldErr := grammar.ParseWithOptions(&dest, s, opts); fieldErr != nil {
			return fieldErr
		}
		r.Value = dest
	}
	return nil
}

// Parse implements parses the given token stream into the receiver according to
// the rule defined by Number.
func (r *Number) Parse(s grammar.TokenStream, opts grammar.ParseOptions) (err *grammar.ParseError) {
	// This is a sequence rule.
	{
		opts = grammar.ParseOptions{
			TokenType:  "number",
			TokenValue: "",
		}
		// Parse Token.
		var dest Token
		if fieldErr := grammar.ParseWithOptions(&dest, s, opts); fieldErr != nil {
			return fieldErr
		}
		r.Value = dest
	}
	return nil
}

// Parse implements parses the given token stream into the receiver according to
// the rule defined by String.
func (r *String) Parse(s grammar.TokenStream, opts grammar.ParseOptions) (err *grammar.ParseError) {
	// This is a sequence rule.
	{
		opts = grammar.ParseOptions{
			TokenType:  "string",
			TokenValue: "",
		}
		// Parse Token.
		var dest Token
		if fieldErr := grammar.ParseWithOptions(&dest, s, opts); fieldErr != nil {
			return fieldErr
		}
		r.Value = dest
	}
	return nil
}
