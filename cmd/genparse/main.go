package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strconv"
	"strings"
	"text/template"
)

func main() {
	// Setup
	log.SetFlags(0)
	flag.Parse()
	parseFuncTemplate, err := template.New("parse").Parse(parseFunc)
	if err != nil {
		log.Fatalf("Invalid template: %s", err)
	}

	// Extract the source file
	var srcFile string
	switch flag.NArg() {
	case 0:
		// go:generate puts the source file in the GOFILE env variable, so this
		// allows adding:
		//
		// //go:generate genparse in the go file containing the grammar
		var ok bool
		srcFile, ok = os.LookupEnv("GOFILE")
		if !ok {
			log.Fatal("GOFILE not defined")
		}
	case 1:
		srcFile = flag.Arg(0)
	default:
		log.Fatal("Only one source file supported")
	}

	// Parse the source file and extract the the struct ASTs
	log.Printf("Parsing rules from %s", srcFile)
	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, srcFile, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Cannot parse file: %s", srcFile)
	}
	ruleTypes := getRuleTypes(astFile.Scope.Objects)

	// Generate the Parse method for the identified rules
	log.Printf("Compiling %s", srcFile)
	var compiledBuf bytes.Buffer
	fmt.Fprintf(&compiledBuf, fileHeader, srcFile, astFile.Name)
	for name, structType := range ruleTypes {
		rule := getRule(name, structType, func(name string) bool {
			return ruleTypes[name] != nil
		})
		log.Printf("...generating (*%s).Parse", name)
		parseFuncTemplate.Execute(&compiledBuf, rule)
	}

	// Format the generated code
	log.Print("Formatting generated code")
	compiled, err := format.Source(compiledBuf.Bytes())
	if err != nil {
		log.Fatalf("Error formatting code: %s", err)
	}

	// Output the code
	outFile := getOutputPath(srcFile)
	log.Printf("Writing generated code to %s", outFile)
	if err := os.WriteFile(outFile, compiled, 0644); err != nil {
		log.Fatalf("Error writing compiled file to %s: %s", outFile, err)
	}
}

func getOutputPath(path string) string {
	ext := filepath.Ext(path)
	return fmt.Sprintf("%s.compiled%s", strings.TrimSuffix(path, ext), ext)
}

func getRuleTypes(objects map[string]*ast.Object) map[string]*ast.StructType {
	ruleTypes := map[string]*ast.StructType{}
	for name, obj := range objects {
		if obj.Kind != ast.Typ {
			continue
		}
		typeSpec, ok := obj.Decl.(*ast.TypeSpec)
		if !ok {
			continue
		}
		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			continue
		}
		if len(structType.Fields.List) == 0 {
			continue
		}
		firstFieldTypeName := getName(structType.Fields.List[0].Type)
		if firstFieldTypeName != "grammar.Rule" && firstFieldTypeName != "grammar.OneOf" {
			continue
		}
		ruleTypes[name] = structType
	}
	return ruleTypes
}

func getRule(typeName string, structType *ast.StructType, isRuleType func(string) bool) *Rule {
	if len(structType.Fields.List) == 0 {
		return nil
	}
	fields := structType.Fields.List
	firstFieldTypeName := getName(fields[0].Type)
	isOneOf := firstFieldTypeName == "grammar.OneOf"
	if isOneOf || firstFieldTypeName == "grammar.Rule" {
		fields = fields[1:]
	}
	var ruleFields []RuleField
	for _, field := range fields {
		fieldType := getFieldType(field.Type)
		fieldName := getFieldName(field)
		if !fieldType.IsValid() {
			panic(fmt.Sprintf("Invalid field %s in type %s", fieldName, typeName))
		}
		fieldType.IsRule = isRuleType(fieldType.Name)
		var options ParseOptions
		if field.Tag != nil {
			tag, _ := strconv.Unquote(field.Tag.Value)
			options = getRuleOptions(tag)
		}

		ruleFields = append(ruleFields, RuleField{
			FieldType:    fieldType,
			Name:         fieldName,
			ParseOptions: options,
		})
	}
	return &Rule{
		Name:   typeName,
		OneOf:  isOneOf,
		Fields: ruleFields,
	}
}

var fileHeader = `
// Code generated by genparse %s; DO NOT EDIT
// +build !nocompiledgrammar
// Use this tag to disable the generated implementations of Parse below

package %s

import "github.com/arnodel/grammar"

`

var parseFunc = `
{{- define "parseDest" -}}
{{ if .FieldType.IsRule }}dest.Parse(s, opts){{ else }}grammar.ParseWithOptions(&dest, s, opts){{ end }}
{{- end }}

// Parse implements parses the given token stream into the receiver according to
// the rule defined by {{ .Name }}.
func (r *{{ .Name }}) Parse(s grammar.TokenStream, opts grammar.ParseOptions) (err *grammar.ParseError) {
{{- if .OneOf }}
	// This is a one-of rule.
	{{- range .Fields }}
	{
		opts = grammar.ParseOptions{
			TokenType: {{ .ParseOptions.TokenType | printf "%q" }},
			TokenValue: {{ .ParseOptions.TokenValue | printf "%q" }},
		}
		{{- if .FieldType.Pointer }}
		// Parse optional {{ .FieldType.Name}}.
		startOpt := s.Save()
		var dest {{ .FieldType.Name }}
		fieldErr := {{ template "parseDest" . }}
		if fieldErr == nil {
			r.{{ .Name }} = &dest
			return nil
		}
		s.Restore(startOpt)
		err = err.Merge(fieldErr)
		{{- else if .FieldType.Array }}
		// Parse sequence of {{ .FieldType.Name }} items.
		startOpt := s.Save()
		var dests []{{ .FieldType.Name}}
		for {
			var dest {{ .FieldType.Name }}
			if fieldErr := {{ template "parseDest" . }}; fieldErr != nil {
				s.Restore(startOpt)
				err = err.Merge(fieldErr)
				break
			}
			dests = append(dests, dest)
		}
		if len(dests) > 0 {
			r.{{ .Name }} = dests
			return nil
		}
		{{- end }}
	}
	{{- end }}
	return err
{{- else }}
	// This is a sequence rule.
	{{- range .Fields }}
	{
		opts = grammar.ParseOptions{
			TokenType: {{ .ParseOptions.TokenType | printf "%q" }},
			TokenValue: {{ .ParseOptions.TokenValue | printf "%q" }},
		}
		{{- if .FieldType.Pointer }}
		// Parse optional {{ .FieldType.Name}}.
		startOpt := s.Save()
		var dest {{ .FieldType.Name }}
		if fieldErr := {{ template "parseDest" . }}; fieldErr != nil {
			s.Restore(startOpt)
		} else {
			r.{{ .Name }} = &dest
		}
		{{- else if .FieldType.Array }}
		// Parse optional sequence of {{ .FieldType.Name }} items.
		var dests []{{ .FieldType.Name}}
		for {
			startOpt := s.Save()
			var dest {{ .FieldType.Name }}
			if fieldErr := {{ template "parseDest" . }}; fieldErr != nil {
				s.Restore(startOpt)
				break
			}
			dests = append(dests, dest)
		}
		r.{{ .Name }} = dests
		{{- else }}
		// Parse {{ .FieldType.Name}}.
		var dest {{ .FieldType.Name }}
		if fieldErr := {{ template "parseDest" . }}; fieldErr != nil {
			return fieldErr
		}
		r.{{ .Name }} = dest
		{{- end }}
	}
	{{- end }}
	return nil
{{- end }}
}
`

type Rule struct {
	Name   string
	OneOf  bool
	Fields []RuleField
}

type RuleField struct {
	FieldType
	ParseOptions
	Name string
}

type ParseOptions struct {
	TokenType  string
	TokenValue string
}

type FieldType struct {
	Name    string
	Pointer bool
	Array   bool
	IsRule  bool
}

func (f FieldType) IsValid() bool {
	return f.Name != ""
}

func (f FieldType) String() string {
	switch {
	case f.Pointer:
		return "*" + f.Name
	case f.Array:
		return "[]" + f.Name
	case f.IsValid():
		return f.Name
	default:
		return "INVALID_TYPE"
	}
}

func getFieldType(e ast.Expr) FieldType {
	switch ee := e.(type) {
	case *ast.ArrayType:
		return FieldType{
			Name:  getName(ee.Elt),
			Array: true,
		}
	case *ast.StarExpr:
		return FieldType{
			Name:    getName(ee.X),
			Pointer: true,
		}
	default:
		return FieldType{Name: getName(e)}
	}
}

func getFieldName(f *ast.Field) string {
	if len(f.Names) > 0 {
		return f.Names[0].Name
	}
	return getUnqualifiedName(f.Type)
}

func getName(e ast.Expr) string {
	switch ee := e.(type) {
	case *ast.Ident:
		return ee.Name
	case *ast.SelectorExpr:
		x := getName(ee.X)
		sel := getName(ee.Sel)
		if x == "" || sel == "" {
			return ""
		}
		return fmt.Sprintf("%s.%s", x, sel)
	default:
		return ""
	}
}

func getUnqualifiedName(e ast.Expr) string {
	switch ee := e.(type) {
	case *ast.StarExpr:
		return getUnqualifiedName(ee.X)
	case *ast.Ident:
		return ee.Name
	case *ast.SelectorExpr:
		return getUnqualifiedName(ee.Sel)
	default:
		return ""
	}
}

func getRuleOptions(tag string) ParseOptions {
	return optionsFromTagValue(reflect.StructTag(tag).Get("tok"))
}

// Copied from the grammar package
func optionsFromTagValue(v string) ParseOptions {
	if i := strings.IndexByte(v, ','); i >= 0 {
		return ParseOptions{
			TokenType:  v[:i],
			TokenValue: v[i+1:],
		}
	}
	return ParseOptions{TokenType: v}
}
